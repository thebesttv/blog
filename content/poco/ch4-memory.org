#+title: 存储器系统

* 存储器

分类:
1. 按与CPU的连接和功能分类
   - 主存储器,内存: CPU能够直接访问的存储器. 用于存放当前运行的程序和
     数据
   - 辅助存储器,外存: CPU不能直接访问. 当需要运行程序和数据时,将它们成
     批调入内存供CPU使用
   - 高速缓冲存储器, Cache: 用于解决CPU与主存间速度匹配问题的高速小容
     量存储器. 对程序与指令透明
2. 按存取方式分类
   - 随机存取存储器, RAM: 按地址随机读写,读写时间与地址无关,主要用于组
     成主存. DRAM, SRAM
   - 只读存储器, ROM: 任何单元的内容只能随机地读取,而不能写入和修改,但
     掉电后数据不会丢失. ROM可以作为主存的一部分,用于存放不变的程序和
     数据,与RAM共享相同的主存空间
   - 顺序存取存储器, SAM (Sequential Access Memory): 信息的排列、寻址
     和读写操作均按顺序进行,存取时间与信息在存储器中的物理位置有关. 信
     息通常是以文件或数据块形式按顺序存放,信息在载体上没有唯一对应的地
     址,完全按顺序存放或读取. 如磁带.
   - 直接存取存储器, DAM (Direct Access Memory): 介于RAM和SAM之间的存
     储器, 也称半顺序存储器. 如机械硬盘,当进行信息存取时,先寻找磁道,属
     于随机方式,然后在磁道中寻找扇区,属于顺序方式.
   - 按内容寻址存储器, CAM, AM (Associated Memory): 先按信息内容寻址,
     再按地址访问.
3. 按存储介质分类
   - 磁存储器: HDD, 磁带, 软盘
   - 半导体存储器: U盘,SSD
   - 光存储器: CD, DVD
4. 按信息的可保存性分类
   - 易失性存储器: 电源掉电后,信息自动丢失. 如半导体RAM
   - 非易失性存储器: 电源掉电后,信息仍能继续保存. 如ROM、磁盘、光盘等

* 主存的组成&基操

{{{image(80)}}}
[[./ch4-memory/main-memory.png]]

存储阵列(存储体): 存储器的核心部分, 地址采用二进制进行编码. 可寻址的最
小单位称为编址单位. 编址方式:
- 按字节(byte)编址
- 按字(word)编址

MAR: Memory Address Register, CPU将地址传给MAR. 周围是单箭头

MDR: Memory Data Register, 周围是双箭头

MFC: 存储器操作完成信号. 若存储器采用异步控制,当一个存取操作完成,会给
出该信号

c/cpp 中 struct 内的整数边界对齐

{{{image(70)}}}
[[./ch4-memory/cpu2ram.png]]

异步 vs. 同步

- 同步: 数据传送在固定的时间间隔内完成,即在一个存取周期内完成. 目前多
  数计算机采用同步方式控制CPU与主存之间的数据传送
- 异步: 数据传送的时间不固定,存储器在完成读/写操作后,需向CPU回送"存储
  器功能完成"信号(MFC),表示一次数据传送完成. 异步传送方式允许选用具有
  不同存取速度的存储器作为主存

** 主要指标

*** 容量

讨论存储芯片的容量时,单位为bit; 讨论计算机存储器的容量时,单位为Byte.

*** 速度

访问时间

*** 总线带宽

*** 价格

** 层次结构

* 存储芯片

几类引脚:
- 地址线
- 数据线
- 读写控制: $\text{R}/\overline{\text{W}}$, $\overline{\text{WE}}$ 都表示高读低写
- 片选信号: $\overline{\text{CS}}$ 低位有效

** 位扩展&字扩展

- 位扩展: 将位数变高, e.g. 用两块 1K\times4b 的组成 1K\times8b
- 字扩展: 将字数变多(即地址变长), 但位数不变, 需要使用新地址的高位作为
  *片选信号*.  e.g. 用四块 16K\times8b 的组成 64K\times8b, 此时位数不
  变, 但地址从 16K(14位) 变成 64K(16位).

* Cache

Cache 是按​*块(block)*​进行管理的, Cache和主存都被分成大小相同的块.  对
于字节编址的系统, 若主存为 1MB (20位), Cache大小为 1KB(10位), 当块大小
为 16B(4位) 时, 主存地址被分成16位块地址和4位​*块内偏移*, Cache地址被分
为6位块地址和4位​*块内偏移*.

设程序运行期间, $N_c$ 为访问 Cache 的总次数 (即总命中数), $N_m$ 为访问
主存的总次数 (即未命中数). $T_c$ 为 Cache 命中的访问时间, 而 $T_m$ 为
未命中时主存的访问时间.

- Cache 命中率 $H = N_c \big/ (N_c + N_m)$
- Cache & 主存的平均访问时间 $T_a = H T_c + (1-H) T_m$
- 带 Cache 存储系统的加速比 $S_p = T_m \big/ T_a$ (即用了 Cache 比不用快多少)
- 访问效率 $e = T_c \big/ T_a$ (即 Cache 发挥了多少作用)

** 直接映像

#+begin_src text
  主存   | 区号(标识) n-m | 区内块号 m | 块内偏移量 |
  Cache                 |   块号 m  | 块内偏移量 |
#+end_src

** 全相联

#+begin_src text
  主存   | 块号(标识) n | 块内偏移量 |
  Cache       | 块号 m | 块内偏移量 |
#+end_src

** 组相联

设主存有 $2^n$ 块, Cache有 $2^m$ 块, Cache内有 $2^g$ 组, 一组有
$2^{m-g}$ 块, 则主存和Cache地址可分为:
# 这边先酱吧, 网页中英文还不是对齐的, 但看起来还行
#+begin_src text
  主存   | 标识 n-g | 组号 g | 块内偏移量 |
  Cache            | 组号 g | 组内块号 m-g | 块内偏移量 |
#+end_src

---

** 题目

Ex1. 某机主存容量为128MB, Cache容量为32KB, 主存与Cache均按 64B 的大小分块.
1. 分别写出主存与Cache采用直接映像和全相联映像时主存与Cache地址的结构
   格式并标出各个字段的位数.
2. 若Cache采用组相联映像, 每组块数为4块.  写出主存与Cache地址的结构格
   式并标出各个字段的位数.  并回答一个主存块可以映像到多少个Cache块中?
   一个Cache块可与多少个主存块有对应关系?

解:
#+begin_verse
块: 64B = 2^6B
主存: 128MB = 2^{27}B \to 2^{21}块
Cache: 32KB = 2^{15}B \to 2^{9}块
#+end_verse

1. 直接映像
   #+begin_src text
     主存   | 区号 12 | 区内块号 9 | 块内偏移 6 |
     Cache           |   块号 9  | 块内偏移 6 |
   #+end_src
   全相联
   #+begin_src text
     主存    | 块号 21 | 块内偏移 6 |
     Cache  | 块号 9  | 块内偏移 6 |
   #+end_src
2. 4路组相联
   #+begin_src text
     主存   | 标识 14 | 组号 7 | 块内偏移 6 |
     Cache           | 组号 7 | 组内块号 2 | 块内偏移 6 |
   #+end_src
   #+begin_verse
   一个主存块可以映像到 4 个Cache块中.
   一个Cache块可与 2^{14} 个主存块有对应关系. (标识不同即可)
   #+end_verse
