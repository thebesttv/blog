#+title: Chapter 2 -- Building Abstractions with Data

* What is meant by data?

*Axiom for rational numbers*: =make-rat=, =numer= and =denom= must
satisfy the condition that, for any integer $n$ and any non-zero
integer $d$, if $x$ is $(\text{make-rat} \; n \; d)$, then:
$$ \frac{(\text{numer} \; x)}{(\text{denom} \; x)} = \frac{n}{d}. $$

*Axiom for pairs*: for any objects =x= and =y=, if =z = (cons x y)=,
then =(car z) = x= and =(cdr z) = y=.  Any implementation satisfying
this axiom can be used:
#+begin_src scheme
  (define (cons x y)
    (lambda (pick)
      (cond [(= pick 0) x]
            [(= pick 1) y])))

  (define (car z) (z 0))

  (define (cdr z) (z 1))
#+end_src
The ability to manipulate procedures as objects automatically provides
the ability to represent compound data.

Another implementation, taken from Ex 2.4:
#+begin_src scheme
  (define (cons x y)
    (λ (m) (m x y)))

  (define (car z)
    (z (λ (p q) p)))

  (define (cdr z)
    (z (λ (p q) q)))
#+end_src

As in Ex 2.5, you can also represent a pair $a$ and $b$ with $2^a 3^b$:
#+begin_src scheme
  (define (cons a b)
    (* (expt 2 a) (expt 3 b)))

  (define (factor x a)
    (define (iter x n)
      (if (zero? (remainder x a))
          (iter (/ x a) (1+ n))
          n))
    (iter x 0))

  (define (car z) (factor z 2))
  (define (cdr z) (factor z 3))
#+end_src

* Tree structure

#+begin_src scheme
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))

  (define (reverse x)
    (define (iter x res)
      (if (null? x)
          res
          (iter (cdr x) (cons (car x)
                              res))))
    (iter x '()))

  (define (deep-reverse x)
    (define (iter x result)
      (if (null? x)
          result
          (let ((first (car x))
                (rest (cdr x)))
            (iter rest
                  (cons (if (pair? first)
                            (iter first '())
                            first)
                        result)))))
    (iter x '()))

  (define (deep-reverse x)
    (reverse
     (map (lambda (x)
            (if (pair? x)
                (deep-reverse x)
                x))
          x)))

  (define (deep-reverse x)
    (if (pair? x)
        (reverse (map deep-reverse x))
        x))

  (define (fringe x)
    (cond ((null? x) '())
          ((pair? (car x)) (append (fringe (car x))
                                   (fringe (cdr x))))
          (else (cons (car x) (fringe (cdr x))))))


  (define (scale-tree tree factor)
    (cond ((null? tree) '())
          ((not (pair? tree)) (* tree factor))
          (else (cons (scale-tree (car tree) factor)
                      (scale-tree (cdr tree) factor)))))

  (define (scale-tree tree factor)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (scale-tree sub-tree factor))
                 (else (* sub-tree factor))))
         tree))


  (define (square-tree tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (square-tree (car tree))
                              (square-tree (cdr tree))))
          (else (square tree))))

  (define (square-tree tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (square-tree sub-tree))
                 (else (square sub-tree))))
         tree))

  (square-tree '(1 (2 (3 4) 5) (6 7)))

  (define (tree-map fun tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (tree-map fun (car tree))
                              (tree-map fun (cdr tree))))
          (else (fun tree))))

  (define (tree-map fun tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (tree-map fun sub-tree))
                 (else (fun sub-tree))))
         tree))
#+end_src

* Sequences as Conventional Interfaces

#+begin_src scheme
  (define (filter predicate sequence)
    (if (null? sequence)
        '()
        (let ([first (car sequence)]
              [rest  (cdr sequence)])
          (if (predicate first)
              (cons first
                    (filter predicate rest))
              (filter predicate rest)))))

  (filter odd? '(1 2 3 4 5 6))            ; (1 3 5)

  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (accumulate * 1 '(1 2 3 4 5))           ; 120
  (accumulate cons '() '(1 2 3 4 5))      ; (1 2 3 4 5)

  (define (map f sequence)
    (accumulate (lambda (first rest)
                  (cons (f first)
                        rest))
                '()
                sequence))

  (map 1+ '(1 2 3))                       ; (2 3 4)

  (define (append s1 s2)
    (accumulate cons s2 s1))

  (append '(1 2 3) '(4 5 6))              ; (1 2 3 4 5 6)

  (define (length s)
    (accumulate (lambda (_ c)
                  (1+ c))
                0 s))

  (length '(1 2 3))                       ; 3

  (define (enumerate-interfal low high)
    (if (> low high)
        '()
        (cons low
              (enumerate-interfal (+ low 1) high))))

  (enumerate-interfal 2 7)                ; (2 3 4 5 6 7)

  (define (enumerate-tree tree)
    (cond [(null? tree) '()]
          [(atom? tree) (list tree)]
          [else (append (enumerate-tree (car tree))
                        (enumerate-tree (cdr tree)))]))

  (enumerate-tree '(1 (2 (3 4)) 5))       ; (1 2 3 4 5)


  (define (sum-odd-squares tree)
    (accumulate + 0
                (map square
                     (filter odd?
                             (enumerate-tree tree)))))

  (define (even-fibs n)
    (accumulate cons '()
                (filter even?
                        (map fib
                             (enumerate-interval 0 n)))))

  (define (salary-of-highest-paid-programmer records)
    (accumulate max 0
                (map salary
                     (filter programmer? records))))
#+end_src

* Folding left & right

Both =fold-left= and =fold-right= takes
- =op=: a procedure with two arguments
- =initial=: the initial value
- =sequence=: the sequence to be accumulated/folded.

#+begin_src scheme
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))

  (define (fold-right op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (fold-right op initial (cdr sequence)))))
#+end_src

But they apply =op= in different directions.
=fold-left= folds from left to right, calls =(op running-sum current-value)=.
=fold-right= folds from right to left, calls =(op current-value running-sum)=.

For operators that satisfy transitivity, the result is the same, but
for others such as division and =cons=, the resutls are different.
#+begin_src scheme
  (fold-left / 1 '(1 2 3))                ; (((1 / 1) / 2) / 3) -> 1/6
  (fold-right / 1 '(1 2 3))               ; (1 / (2 / (3 / 1))) -> 3/2
#+end_src

You can implement =reverse= using either, but with different =op=:
#+begin_src scheme
  (define (reverse sequence)
    (fold-left (lambda (sum cur)
                 (cons cur sum))
               '()
               sequence))

  (define (reverse sequence)
    (fold-right (lambda (cur sum)
                  (append sum (list cur)))
                '()
                sequence))
#+end_src

* Exercises
** Ex 2.6 -- Church numerals
#+begin_quote
In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as non-negative integers are
concerned) by implementing 0 and the operation of adding 1 as

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as /Church numerals/, after its inventor,
Alonzo Church, the logician who invented the calculus.

Define =one= and =two= directly (not in terms of =zero= and
=add-1=). (Hint: Use substitution to evaluate =(add-1 zero)=). Give a
direct definition of the addition procedure =+= (not in terms of
repeated application of =add-1=).
#+end_quote

First we have =zero= and =add-1=:
#+begin_src scheme
  (define zero
    (λ (f)
      (λ (x)
        x)))

  (define (add-1 n)
    (λ (f)
      (λ (x)
        (f ((n f) x)))))
#+end_src

Use the substitution model to calculate =one= and =two=, we get:
#+begin_src scheme
  (define one
    (λ (f)
      (λ (x)
        (f x))))

  (define two
    (λ (f)
      (λ (x)
        (f (f x)))))
#+end_src

In order to get 3, we can add =one= and =two=, and obtain as result
something like =(f (f (f x)))=.  =((one f) x)= is =(f x)=, =(two f)=
is =(λ (x) (f (f x)))=.  Make =((one f) x)= the argument of =(two f)=,
we get:
#+begin_src scheme
  ((two f) ((one f) x))                   ; => (f (f (f x)))
#+end_src

So addition is:
#+begin_src scheme
  (define (add a b)
    (λ (f)
      (λ (x)
        ((a f) ((b f) x)))))
#+end_src

One can use these as normal integers:
#+begin_src scheme
  (define (church->int ch)
    ((ch 1+) 0))

  (church->int zero)                      ; 0
  (church->int two)                       ; 2
  (church->int (add one two))             ; 3

  (define three (add one two))
  (church->int (add two three))           ; 5
#+end_src

Here's a more concise implementation of =add= that I don't quite
understand =@_@=
#+begin_src scheme
  (define (add a b)
    ((a add-1) b))
#+end_src

** Ex 2.20 -- dotted-tail notation
#+begin_quote
The procedures =+=, =*=, and =list= take arbitrary numbers of
arguments.  One way to define such procedures is to use define with
/dotted-tail notation/.  In a procedure definition, a parameter list
that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as
values the initial arguments, as usual, but the final parameter's
value will be a /list/ of any remaining arguments.  For instance,
given the definition
#+begin_src scheme
  (define (f x y . z) <body>)
#+end_src
the procedure =f= can be called with two or more arguments.
If we evaluate
#+begin_src scheme
  (f 1 2 3 4 5 6)
#+end_src
then in the body of =f=, =x= will be 1, =y= will be 2, and =z= will be
the list =(3 4 5 6)=.  Given the definition
#+begin_src scheme
  (define (g . w) <body>)
#+end_src
the procedure =g= can be called with zero or more arguments.
If we evaluate
#+begin_src scheme
  (g 1 2 3 4 5 6)
#+end_src
then in the body of =g=, w will be the list =(1 2 3 4 5 6)=.

Use this notation to write a procedure =same-parity= that takes one or
more integers and returns a list of all the arguments that have the
same even-odd parity as the first argument.  For example,
#+begin_src scheme
  (same-parity 1 2 3 4 5 6 7)
  (1 3 5 7)

  (same-parity 2 3 4 5 6 7)
  (2 4 6)
#+end_src
#+end_quote

#+begin_src scheme
  (define (same-parity first . rest)
    (let ([pred (if (odd? first)
                    odd?
                    even?)])
      (define (iter l)
        (if (null? l)
            '()
            (let ([first (car l)]
                  [rest  (cdr l)])
              (if (pred first)
                  (cons first (iter rest))
                  (iter rest)))))
      (cons first
            (iter rest))))

  ;;; old solution
  (define (same-parity first . rest)
    (let ((yes? (if (odd? first)
                    odd?
                    even?)))
      (define (iter l res)
        (cond ((null? l) res)
              ((yes? (car l)) (iter (cdr l) (cons (car l) res)))
              (else (iter (cdr l) res))))
      (cons first
            (reverse (iter rest '())))))
#+end_src

** Ex 2.27 -- deep reverse

#+begin_quote
Modify your =reverse= procedure of Exercise 2.18 to produce a
=deep-reverse= procedure that takes a list as argument and returns as
its value the list with its elements reversed and with all sublists
deep-reversed as well.  For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4))) ; ((1 2) (3 4))
  (reverse x)                             ; ((3 4) (1 2))
  (deep-reverse x)                        ; ((4 3) (2 1))
#+end_src
#+end_quote

#+begin_src scheme
  (define (deep-reverse tree)
    (if (atom? tree)
        tree
        (reverse (map deep-reverse tree))))
#+end_src

** Ex 2.28 -- fringe

#+begin_quote
Write a procedure =fringe= that takes as argument a tree (represented as
a list) and returns a list whose elements are all the leaves of the
tree arranged in left-to-right order.  For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4)))
  (fringe x)                              ; (1 2 3 4)
  (fringe (list x x))                     ; (1 2 3 4 1 2 3 4)
#+end_src
#+end_quote

#+begin_src scheme
  (define (fringe tree)
    (cond [(null? tree) '()]
          [(atom? tree) (list tree)]
          [else (append (fringe (car tree))
                        (fringe (cdr tree)))]))

  (define (fringe tree)
    (define (iter tree res)
      (cond [(null? tree) res]
            [(atom? tree) (cons tree res)]
            [else (iter (car tree)
                        (iter (cdr tree) res))]))
    (iter tree '()))
#+end_src

** Ex 2.32 -- subset
#+begin_quote
We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists. For
example, if the set is =(1 2 3)=, then the set of all subsets is =(()
(3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))=. Complete the following
definition of a procedure that generates the set of subsets of a set
and give a clear explanation of why it works:

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map <??> rest)))))
#+end_src
#+end_quote

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ([rest (subsets (cdr s))])
          (append rest
                  (map (lambda (x)
                         (cons (car s) x))
                       rest)))))
#+end_src

** Ex 2.35 -- counting leaves

#+begin_quote
Redefine count-leaves from Section 2.2.2 as an accumulation.
#+end_quote

#+begin_src scheme
  (define (count-leaves tree)
    (accumulate + 0
                (map (lambda (tree)
                       (if (atom? tree)
                           1
                           (count-leaves tree)))
                     tree)))
#+end_src
This seems fine, but it will count the empty list as a leaf:
#+begin_src scheme
  (count-leaves '(1 2 (3 (4 5) 6) 7))     ; 7
  (count-leaves '(1 2 (3 (4 5) 6) 7 ()))  ; 8
#+end_src

Take into consideration the empty list ='()=:
#+begin_src scheme
  (define (count-leaves tree)
    (accumulate + 0
                (map (lambda (tree)
                       (cond [(null? tree) 0]
                             [(atom? tree) 1]
                             [else (count-leaves tree)]))
                     tree)))

  (count-leaves '(1 2 (3 (4 5) 6) 7))     ; 7
  (count-leaves '(1 2 (3 (4 5) 6) 7 ()))  ; 7
#+end_src
