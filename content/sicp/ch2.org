#+title: Chapter 2 -- Building Abstractions with Data

* What is meant by data?

*Axiom for rational numbers*: =make-rat=, =numer= and =denom= must
satisfy the condition that, for any integer $n$ and any non-zero
integer $d$, if $x$ is $(\text{make-rat} \; n \; d)$, then:
$$ \frac{(\text{numer} \; x)}{(\text{denom} \; x)} = \frac{n}{d}. $$

*Axiom for pairs*: for any objects =x= and =y=, if =z = (cons x y)=,
then =(car z) = x= and =(cdr z) = y=.  Any implementation satisfying
this axiom can be used:
#+begin_src scheme
  (define (cons x y)
    (lambda (pick)
      (cond [(= pick 0) x]
            [(= pick 1) y])))

  (define (car z) (z 0))

  (define (cdr z) (z 1))
#+end_src
The ability to manipulate procedures as objects automatically provides
the ability to represent compound data.

Another implementation, taken from Ex 2.4:
#+begin_src scheme
  (define (cons x y)
    (λ (m) (m x y)))

  (define (car z)
    (z (λ (p q) p)))

  (define (cdr z)
    (z (λ (p q) q)))
#+end_src

As in Ex 2.5, you can also represent a pair $a$ and $b$ with $2^a 3^b$:
#+begin_src scheme
  (define (cons a b)
    (* (expt 2 a) (expt 3 b)))

  (define (factor x a)
    (define (iter x n)
      (if (zero? (remainder x a))
          (iter (/ x a) (1+ n))
          n))
    (iter x 0))

  (define (car z) (factor z 2))
  (define (cdr z) (factor z 3))
#+end_src

* Tree structure

#+begin_src scheme
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))

  (define (reverse x)
    (define (iter x res)
      (if (null? x)
          res
          (iter (cdr x) (cons (car x)
                              res))))
    (iter x '()))

  (define (deep-reverse x)
    (define (iter x result)
      (if (null? x)
          result
          (let ((first (car x))
                (rest (cdr x)))
            (iter rest
                  (cons (if (pair? first)
                            (iter first '())
                            first)
                        result)))))
    (iter x '()))

  (define (deep-reverse x)
    (reverse
     (map (lambda (x)
            (if (pair? x)
                (deep-reverse x)
                x))
          x)))

  (define (deep-reverse x)
    (if (pair? x)
        (reverse (map deep-reverse x))
        x))

  (define (fringe x)
    (cond ((null? x) '())
          ((pair? (car x)) (append (fringe (car x))
                                   (fringe (cdr x))))
          (else (cons (car x) (fringe (cdr x))))))


  (define (scale-tree tree factor)
    (cond ((null? tree) '())
          ((not (pair? tree)) (* tree factor))
          (else (cons (scale-tree (car tree) factor)
                      (scale-tree (cdr tree) factor)))))

  (define (scale-tree tree factor)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (scale-tree sub-tree factor))
                 (else (* sub-tree factor))))
         tree))


  (define (square-tree tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (square-tree (car tree))
                              (square-tree (cdr tree))))
          (else (square tree))))

  (define (square-tree tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (square-tree sub-tree))
                 (else (square sub-tree))))
         tree))

  (square-tree '(1 (2 (3 4) 5) (6 7)))

  (define (tree-map fun tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (tree-map fun (car tree))
                              (tree-map fun (cdr tree))))
          (else (fun tree))))

  (define (tree-map fun tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (tree-map fun sub-tree))
                 (else (fun sub-tree))))
         tree))
#+end_src

* Sequences as Conventional Interfaces
** Sequence Operations

#+begin_src scheme
  (define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence))
           (cons (car sequence)
                 (filter predicate (cdr sequence))))
          (else (filter predicate (cdr sequence)))))

  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (accumulate cons '() '(1 2 3 4 5))
  ;;; Value: (1 2 3 4 5)

  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low
              (enumerate-interval (+ 1 low)
                                  high))))

  (enumerate-interval 2 7)
  ;;; Value: (2 3 4 5 6 7)

  (define (enumerate-tree tree)
    (cond ((null? tree) '())
          ((not-pair? tree) (list tree))
          (else (append (enumerate-tree (car tree))
                        (enumerate-tree (cdr tree))))))

  (enumerate-tree '(1 (2 (3 4) (5))))
  ;;; Value: (1 2 3 4 5)


  (define (sum-odd-squares tree)
    (accumulate + 0
                (map square
                     (filter odd?
                             (enumerate-tree tree)))))

  (define (even-fibs n)
    (accumulate cons '()
                (filter even?
                        (map fib
                             (enumerate-interval 0 n)))))

  (define (salary-of-highest-paid-programmer records)
    (accumulate max 0
                (map salary
                     (filter programmer? records))))
#+end_src

* Exercises
** Ex 2.6 -- Church numerals
#+begin_quote
In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as non-negative integers are
concerned) by implementing 0 and the operation of adding 1 as

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as /Church numerals/, after its inventor,
Alonzo Church, the logician who invented the calculus.

Define =one= and =two= directly (not in terms of =zero= and
=add-1=). (Hint: Use substitution to evaluate =(add-1 zero)=). Give a
direct definition of the addition procedure =+= (not in terms of
repeated application of =add-1=).
#+end_quote

First we have =zero= and =add-1=:
#+begin_src scheme
  (define zero
    (λ (f)
      (λ (x)
        x)))

  (define (add-1 n)
    (λ (f)
      (λ (x)
        (f ((n f) x)))))
#+end_src

Use the substitution model to calculate =one= and =two=, we get:
#+begin_src scheme
  (define one
    (λ (f)
      (λ (x)
        (f x))))

  (define two
    (λ (f)
      (λ (x)
        (f (f x)))))
#+end_src

In order to get 3, we can add =one= and =two=, and obtain as result
something like =(f (f (f x)))=.  =((one f) x)= is =(f x)=, =(two f)=
is =(λ (x) (f (f x)))=.  Make =((one f) x)= the argument of =(two f)=,
we get:
#+begin_src scheme
  ((two f) ((one f) x))                   ; => (f (f (f x)))
#+end_src

So addition is:
#+begin_src scheme
  (define (add a b)
    (λ (f)
      (λ (x)
        ((a f) ((b f) x)))))
#+end_src

One can use these as normal integers:
#+begin_src scheme
  (define (church->int ch)
    ((ch 1+) 0))

  (church->int zero)                      ; 0
  (church->int two)                       ; 2
  (church->int (add one two))             ; 3

  (define three (add one two))
  (church->int (add two three))           ; 5
#+end_src

Here's a more concise implementation of =add= that I don't quite
understand =@_@=
#+begin_src scheme
  (define (add a b)
    ((a add-1) b))
#+end_src

** Ex 2.20 -- dotted-tail notation
#+begin_quote
The procedures =+=, =*=, and =list= take arbitrary numbers of
arguments. One way to define such procedures is to use define with
/dotted-tail notation/. In a procedure definition, a parameter list
that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as
values the initial arguments, as usual, but the final parameter's
value will be a /list/ of any remaining arguments. For instance, given
the definition
#+begin_src scheme
  (define (f x y . z) <body>)
#+end_src

the procedure =f= can be called with two or more arguments. If we
evaluate

#+begin_src scheme
  (f 1 2 3 4 5 6)
#+end_src

then in the body of =f=, =x= will be 1, =y= will be 2, and =z= will be
the list =(3 4 5 6)=. Given the definition

#+begin_src scheme
  (define (g . w) <body>)
#+end_src

the procedure =g= can be called with zero or more arguments. If we
evaluate

#+begin_src scheme
  (g 1 2 3 4 5 6)
#+end_src

then in the body of =g=, w will be the list =(1 2 3 4 5 6)=.

Use this notation to write a procedure =same-parity= that takes one or
more integers and returns a list of all the arguments that have the
same even-odd parity as the first argument. For example,

#+begin_src scheme
  (same-parity 1 2 3 4 5 6 7)
  (1 3 5 7)

  (same-parity 2 3 4 5 6 7)
  (2 4 6)
#+end_src
#+end_quote

对于相同奇偶性的检测，可以 =let= 一个变量 =yes?= ，如果 =frist= 是奇数
=yes?= 就是 =odd?= ，否则 =yes?= 就是 =even?= 。使用 iterative 的方法，
得到的 =res= 是倒序，就 =reverse= 一下，最后 =cons= 上 =first= 就行啦。

#+begin_src scheme
  (define (same-parity first . rest)
    (let ((yes? (if (odd? first)
                    odd?
                    even?)))
      (define (iter l res)
        (cond ((null? l) res)
              ((yes? (car l)) (iter (cdr l) (cons (car l) res)))
              (else (iter (cdr l) res))))
      (cons first
            (reverse (iter rest '())))))
#+end_src
** Ex 2.32 -- subset
#+begin_quote
We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists. For
example, if the set is =(1 2 3)=, then the set of all subsets is =(()
(3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))=. Complete the following
definition of a procedure that generates the set of subsets of a set
and give a clear explanation of why it works:

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map <??> rest)))))
#+end_src
#+end_quote

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        '(())
        (let ((rest (subsets (cdr s))))
          (append rest (map (lambda (x)
                              (cons (car s) x))
                            rest)))))
#+end_src
