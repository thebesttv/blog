#+title: Chapter 2 -- Building Abstractions with Data

* Exercises
** Ex 2.6 -- Church numerals
#+begin_quote
In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as nonnegative integers are
concerned) by implementing 0 and the operation of adding 1 as

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as /Church numerals/, after its inventor,
Alonzo Church, the logician who invented the calculus.

Define =one= and =two= directly (not in terms of =zero= and
=add-1=). (Hint: Use substitution to evaluate =(add-1 zero)=). Give a
direct definition of the addition procedure =+= (not in terms of
repeated application of =add-1=).
#+end_quote

就先把 =lambda= 换成 =λ= ，好看又好写，嘿嘿：

#+begin_src scheme
  (define zero (λ (f)
                 (λ (x) x)))

  (define (add-1 n)
    (λ (f)
      (λ (x)
        (f ((n f) x)))))

  (define one (add-1 zero))
  (define two (add-1 one))

  (define (1+ n)
    (+ 1 n))

  (define (add a b)
    (λ (f)
      (λ (x)
        ((a f) ((b f) x)))))
#+end_src

还是看人家的[[http://community.schemewiki.org/?sicp-ex-2.6][解答]]吧。下面这个评论里的代码虽然不太符合要求，不过也好腻害！
就是 =b= 再配上 =a= 次 =add-1= 。

#+begin_src scheme
  (define (add a b)
    ((a add-1) b))
#+end_src
** Ex 2.20 -- dotted-tail notation
#+begin_quote
The procedures =+=, =*=, and =list= take arbitrary numbers of
arguments. One way to define such procedures is to use define with
/dotted-tail notation/. In a procedure definition, a parameter list
that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as
values the initial arguments, as usual, but the final parameter's
value will be a /list/ of any remaining arguments. For instance, given
the definition
#+begin_src scheme
  (define (f x y . z) <body>)
#+end_src

the procedure =f= can be called with two or more arguments. If we
evaluate

#+begin_src scheme
  (f 1 2 3 4 5 6)
#+end_src

then in the body of =f=, =x= will be 1, =y= will be 2, and =z= will be
the list =(3 4 5 6)=. Given the definition

#+begin_src scheme
  (define (g . w) <body>)
#+end_src

the procedure =g= can be called with zero or more arguments. If we
evaluate

#+begin_src scheme
  (g 1 2 3 4 5 6)
#+end_src

then in the body of =g=, w will be the list =(1 2 3 4 5 6)=.

Use this notation to write a procedure =same-parity= that takes one or
more integers and returns a list of all the arguments that have the
same even-odd parity as the first argument. For example,

#+begin_src scheme
  (same-parity 1 2 3 4 5 6 7)
  (1 3 5 7)

  (same-parity 2 3 4 5 6 7)
  (2 4 6)
#+end_src
#+end_quote

对于相同奇偶性的检测，可以 =let= 一个变量 =yes?= ，如果 =frist= 是奇数
=yes?= 就是 =odd?= ，否则 =yes?= 就是 =even?= 。使用 iterative 的方法，
得到的 =res= 是倒序，就 =reverse= 一下，最后 =cons= 上 =first= 就行啦。

#+begin_src scheme
  (define (same-parity first . rest)
    (let ((yes? (if (odd? first)
                    odd?
                    even?)))
      (define (iter l res)
        (cond ((null? l) res)
              ((yes? (car l)) (iter (cdr l) (cons (car l) res)))
              (else (iter (cdr l) res))))
      (cons first
            (reverse (iter rest '())))))
#+end_src
