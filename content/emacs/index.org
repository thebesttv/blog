#+title: Fun with Emacs

* å„ç§æ–‡ç« 
- [[https://emacs.stackexchange.com/questions/56230/when-use-setq-or-set][When use setq or set ']]
- [[https://nullprogram.com/blog/2017/01/30/][How to Write Fast(er) Emacs Lisp]]
* ä¸­æ–‡æ–­è¡Œ
  å¯ç”¨ auto-fill æ¨¡å¼åï¼Œä¸­æ–‡æ–­è¡Œåœ¨å¯¼å‡ºæ—¶ä¼šå‡ºç°ç©ºæ ¼ï¼Œå°±å…ˆç›´æ¥æŠ„äººå®¶çš„
  ä»£ç å•¦ï¼š[[https://github.com/hick/emacs-chinese#%E4%B8%AD%E6%96%87%E6%96%AD%E8%A1%8C][Emacsç›¸å…³ä¸­æ–‡é—®é¢˜ä»¥åŠè§£å†³æ–¹æ¡ˆ]]ã€‚

  ä¸€å¼€å§‹ç”¨çš„ Feng Shu çš„ç‰ˆæœ¬ï¼Œä½†å‘ç°ä¸­æ–‡å’Œä»£ç å—ä¹‹é—´ç©ºæ ¼ä¼šæ¶ˆå¤±ï¼Œäºæ˜¯å°±
  æ¢æˆ zwz å®ç°äº†ã€‚

  #+BEGIN_SRC elisp
    ;;; ä¸‹é¢ä¸€æ®µæ˜¯ zwz çš„, ä½œè€…å£°æ˜åªé€‚åº” org-mode 8.0 ä»¥åŠä»¥ä¸Šç‰ˆæœ¬
    (defun clear-single-linebreak-in-cjk-string (string)
      "clear single line-break between cjk characters that is usually soft line-breaks"
      (let* ((regexp "\\([\u4E00-\u9FA5]\\)\n\\([\u4E00-\u9FA5]\\)")
             (start (string-match regexp string)))
        (while start
          (setq string (replace-match "\\1\\2" nil nil string)
                start (string-match regexp string start))))
      string)

    (defun ox-html-clear-single-linebreak-for-cjk (string backend info)
      (when (org-export-derived-backend-p backend 'html)
        (clear-single-linebreak-in-cjk-string string)))

    (add-to-list 'org-export-filter-final-output-functions
                 'ox-html-clear-single-linebreak-for-cjk)
  #+END_SRC

* å…³äº Code Block çš„ä¸€äº›å°æŠ€å·§ - [[https://orgmode.org/guide/Working-with-Source-Code.html][Working with Source Code]]
  Use =C-c '= to edit the current code block. It opens a new major
  mode edit buffer containing the body of the source code block, ready
  for any edits. Use =C-c '= again to close the buffer and return to
  the Org buffer (this saves editing results); or use =C-c C-k= to
  abort editing and discard results.

* å„ç§æ–‡ä»¶æ“ä½œ
** Concat file name without =concat=
   [[https://www.reddit.com/r/emacs/comments/umb24/expandfilename_is_good_for_path_concat_too/][=expand-file-name= is good for path concat too]]

   When joining file paths, use =expand-file-name= instead of concat.

   #+BEGIN_SRC elisp :exports both
     (expand-file-name "eserver" "/home/user/")
   #+END_SRC

   è¯„è®ºåŒºè¿˜æœ‰æ›´æ£’çš„ trick ğŸ˜ï¼š
   #+BEGIN_SRC elisp :exports both
     (require 'cl-lib)
     (defun concat-path (&rest parts)
       (cl-reduce (lambda (a b)
                    (expand-file-name b a))
                  parts))
     (concat-path "/home/user" "eserver" "blog")
   #+END_SRC

   ä¸è¿‡ =expand-file-name= åªé€‚åˆç»å¯¹è·¯å¾„ï¼Œåœ¨ [[https://stackoverflow.com/questions/3964715/what-is-the-correct-way-to-join-multiple-path-components-into-a-single-complete][What is the correct way
   to join multiple path components into a single complete path in
   emacs lisp?]] é‡Œæœ‰å…³äº =concat=, =expand-file-name=, è¿˜æœ‰ =f.el= é‡Œ
   =f-join= çš„è®¨è®ºï¼ˆæ‡’å¾—çœ‹äº†ğŸ˜œ
** Check for file existence
   [[https://emacs.stackexchange.com/questions/34392/how-to-check-if-a-directory-exists-in-elisp][How to check if a directory exists in elisp?]]

   - =file-exists-p FILENAME= :: Return =t= if file =FILENAME= exists
     (whether or not you can read it).
   - =file-directory-p FILENAME= :: Return =t= if =FILENAME= names an
     *existing* directory.


   #+BEGIN_SRC elisp
     (defun directory-non-hidden-files (directory)
       "Return absolute path of all non-hidden & non-backup files in DIRECTORY.
     This does not opreate recursively. Only files / directories under the current
     directory is shown."
       ;; å¦‚è¿‡å†å¯¹ç»“æœéƒ½æ¥ä¸ª file-direcotry-p å°±å¯ä»¥è¿”å›æ–‡ä»¶å¤¹å•¦
       (directory-files directory t
                        ;; dircard ".", "..", hidden, and emacs-backup files
                        (rx string-start (not ?.) (* anything) (not ?~) string-end)))
   #+END_SRC

* XML Parsing

[[https://www.emacswiki.org/emacs/XmlParsers][å„ç§ XML Parser]]ï¼Œè¿˜æœ‰ =xml.el= çš„[[https://www.emacswiki.org/emacs/XmlParserExamples][ä¾‹å­]]ï¼Œè¿™é‡Œå°±ä»‹ç»ä¸€ä¸‹ =xml.el= å§ï¼š

=xml.el= ä¸»è¦æœ‰ä¸¤ä¸ªå‡½æ•°ï¼š =xml-parse-file= å’Œ =xml-parse-region= ï¼Œå®ƒ
ä»¬ä¼šè¿”å›ä¸€ä¸ª XML parse treeï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

#+begin_src text
  xml-list   ::= (node node ...)
  node       ::= (qname attribute-list . child_node_list)
  child_node_list ::= child_node child_node ...
  child_node ::= node | string
  qname      ::= (:namespace-uri . "name") | "name"
  attribute_list ::= ((qname . "value") (qname . "value") ...)
                     | nil
  string     ::= "..."
#+end_src

The XML parse tree xml-list is a list of nodes, where each node is
made up of _its name, alist of attributes, and child nodes_. A child
node can either be _a string or a new node_.

Here's a XML example:
#+begin_src xml
  <post time="20050716234509" id="010101">
    <login>Test</login>
    <msg>Here is the message</msg>
    <info>My UA</info>
  </post>
#+end_src

Here's code to parse it:

#+begin_src elisp
  (let* ((xml "<post time=\"20050716234509\" id=\"010101\">
                 <login>Test</login>
                 <msg>Here is the message</msg>
                 <info>My UA</info>
               </post>")
         (root (with-temp-buffer
                 (insert xml)
                 (xml-parse-region)))
         (post  (car root))
         (attrs (xml-node-attributes post))
         (time  (cdr (assq 'time attrs)))
         (msg   (car (xml-get-children post 'msg)))
         (text  (car (xml-node-children msg))))
    (message "time: %s, message '%s'" time text))
#+end_src

#+begin_src elisp
  "time: 20050716234509, message â€™Here is the messageâ€™"
#+end_src

Within =let*=, =root= is a list of a single =post= node:

#+begin_src elisp
  ((post ((time . "20050716234509") (id . "010101"))
         "\n               "
         (login nil "Test")
         "\n               "
         (msg nil "Here is the message")
         "\n               "
         (info nil "My UA")
         "\n             "))
#+end_src

Here, =((time . "20050716234509") (id . "010101"))= is the attribute
alist , and the rest, both strings & nodes, are child nodes of =post=.
The attribute list =attr= is extracted with =xml-node-attributes=, you
can also get a certain attribute with =xml-get-attribute= &
=xml-get-attribute-or-nil=.

#+begin_src elisp
  (xml-get-attribute post 'time)
#+end_src

#+begin_src elisp
  "20050716234509"
#+end_src

=xml-node-children= & =xml-get-children= return either all children,
or children matching a specific name:

#+begin_src elisp
  (xml-get-children post 'msg)
#+end_src

#+begin_src elisp
  ;;; only children named msg
  ((msg nil "Here is the message"))
#+end_src

#+begin_src elisp
  (xml-node-children post)
#+end_src

#+begin_src elisp
  ;;; a list of all children under post
  ("\n                 "
   (login nil "Test")
   "\n                 "
   (msg nil "Here is the message")
   "\n                 "
   (info nil "My UA")
   "\n               ")
#+end_src

* ç»‘å®š 80 å£

[[https://superuser.com/questions/710253/allow-non-root-process-to-bind-to-port-80-and-443][Allow non-root process to bind to port 80 and 443?]]

åŸºæœ¬å°±æ˜¯å®‰è£… =authbind=â€‹ï¼Œç„¶åå» =/etc/authbind/byport/= é‡Œé¢å»ºä¸€ä¸ªä»¥ç«¯
å£å·å‘½åçš„æ–‡ä»¶ï¼ˆæ¯”å¦‚ =/etc/authbind/byport/80=â€‹ï¼‰ï¼Œå½“å‰ç”¨æˆ·å¯¹å…¶è¦æœ‰
execute æƒé™ï¼Œæœ€åç”¨ =authbind= æ¥å¯åŠ¨å‘½ä»¤å³å¯ã€‚

* å®šæ—¶æ›´æ–°å¹¶é‡å¯ EServer

æ„Ÿè§‰è¿˜æ˜¯tmuxæœ€æ–¹ä¾¿,ç›´æ¥ä¸€ä¸ªshellè„šæœ¬å°±è¡Œäº†:
#+begin_src shell
  while true; do
      ./update.sh
      ./restart-server.sh
      sleep 3600
  done
#+end_src
