#+title: Fun with Emacs

* ä¸­æ–‡æ–­è¡Œ
  å¯ç”¨ auto-fill æ¨¡å¼åï¼Œä¸­æ–‡æ–­è¡Œåœ¨å¯¼å‡ºæ—¶ä¼šå‡ºç°ç©ºæ ¼ï¼Œå°±å…ˆç›´æ¥æŠ„äººå®¶çš„
  ä»£ç å•¦ï¼š [[https://github.com/hick/emacs-chinese#%E4%B8%AD%E6%96%87%E6%96%AD%E8%A1%8C][Emacsç›¸å…³ä¸­æ–‡é—®é¢˜ä»¥åŠè§£å†³æ–¹æ¡ˆ]]ã€‚

  ä¸€å¼€å§‹ç”¨çš„ Feng Shu çš„ç‰ˆæœ¬ï¼Œä½†å‘ç°ä¸­æ–‡å’Œä»£ç å—ä¹‹é—´ç©ºæ ¼ä¼šæ¶ˆå¤±ï¼Œäºæ˜¯å°±
  æ¢æˆ zyz å®ç°äº†ã€‚

  #+BEGIN_SRC elisp
    ;;; ä¸‹é¢ä¸€æ®µæ˜¯ zwz çš„, ä½œè€…å£°æ˜åªé€‚åº” org-mode 8.0 ä»¥åŠä»¥ä¸Šç‰ˆæœ¬
    (defun clear-single-linebreak-in-cjk-string (string)
      "clear single line-break between cjk characters that is usually soft line-breaks"
      (let* ((regexp "\\([\u4E00-\u9FA5]\\)\n\\([\u4E00-\u9FA5]\\)")
             (start (string-match regexp string)))
        (while start
          (setq string (replace-match "\\1\\2" nil nil string)
                start (string-match regexp string start))))
      string)

    (defun ox-html-clear-single-linebreak-for-cjk (string backend info)
      (when (org-export-derived-backend-p backend 'html)
        (clear-single-linebreak-in-cjk-string string)))

    (add-to-list 'org-export-filter-final-output-functions
                 'ox-html-clear-single-linebreak-for-cjk)
  #+END_SRC

* å…³äº Code Block çš„ä¸€äº›å°æŠ€å·§ - [[https://orgmode.org/guide/Working-with-Source-Code.html][Working with Source Code]]
  Use =C-c '= to edit the current code block. It opens a new major
  mode edit buffer containing the body of the source code block, ready
  for any edits. Use =C-c '= again to close the buffer and return to
  the Org buffer (this saves editing results); or use =C-c C-k= to
  abort editing and discard results.

* å„ç§æ–‡ä»¶æ“ä½œ
** Concat file name without =concat=
   [[https://www.reddit.com/r/emacs/comments/umb24/expandfilename_is_good_for_path_concat_too/][=expand-file-name= is good for path concat too]]

   When joining file paths, use =expand-file-name= instead of concat.

   #+BEGIN_SRC elisp :exports both
     (expand-file-name "eserver" "/home/user/")
   #+END_SRC

   è¯„è®ºåŒºè¿˜æœ‰æ›´æ£’çš„ trick ğŸ˜ï¼š
   #+BEGIN_SRC elisp :exports both
     (require 'cl-lib)
     (defun concat-path (&rest parts)
       (cl-reduce (lambda (a b)
                    (expand-file-name b a))
                  parts))
     (concat-path "/home/user" "eserver" "blog")
   #+END_SRC

   ä¸è¿‡ =expand-file-name= åªé€‚åˆç»å¯¹è·¯å¾„ï¼Œåœ¨ [[https://stackoverflow.com/questions/3964715/what-is-the-correct-way-to-join-multiple-path-components-into-a-single-complete][What is the correct way
   to join multiple path components into a single complete path in
   emacs lisp?]] é‡Œæœ‰å…³äº =concat=, =expand-file-name=, è¿˜æœ‰ =f.el= é‡Œ
   =f-join= çš„è®¨è®ºï¼ˆæ‡’å¾—çœ‹äº†ğŸ˜œ
** Check for file existence
   [[https://emacs.stackexchange.com/questions/34392/how-to-check-if-a-directory-exists-in-elisp][How to check if a directory exists in elisp?]]

   - =file-exists-p FILENAME= :: Return =t= if file =FILENAME= exists
     (whether or not you can read it).
   - =file-directory-p FILENAME= :: Return =t= if =FILENAME= names an
     *existing* directory.


   #+BEGIN_SRC elisp
     (defun directory-non-hidden-files (directory)
       "Return absolute path of all non-hidden & non-backup files in DIRECTORY.
     This does not opreate recursively. Only files / directories under the current
     directory is shown."
       (directory-files directory t
                        ;; dircard ".", "..", hidden, and emacs-backup files
                        (rx string-start (not ?.) (* anything) (not ?~) string-end)))
   #+END_SRC
