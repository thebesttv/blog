#+title: Chapter 2 --- Building Abstractions with Data

* What is meant by data?

*Axiom for rational numbers*: =make-rat=, =numer= and =denom= must
satisfy the condition that, for any integer $n$ and any non-zero
integer $d$, if $x$ is $(\text{make-rat} \; n \; d)$, then:
$$ \frac{(\text{numer} \; x)}{(\text{denom} \; x)} = \frac{n}{d}. $$

*Axiom for pairs*: for any objects =x= and =y=, if =z = (cons x y)=,
then =(car z) = x= and =(cdr z) = y=.  Any implementation satisfying
this axiom can be used:
#+begin_src scheme
  (define (cons x y)
    (lambda (pick)
      (cond [(= pick 0) x]
            [(= pick 1) y])))

  (define (car z) (z 0))

  (define (cdr z) (z 1))
#+end_src
The ability to manipulate procedures as objects automatically provides
the ability to represent compound data.

Another implementation, taken from Ex 2.4:
#+begin_src scheme
  (define (cons x y)
    (λ (m) (m x y)))

  (define (car z)
    (z (λ (p q) p)))

  (define (cdr z)
    (z (λ (p q) q)))
#+end_src

As in Ex 2.5, you can also represent a pair $a$ and $b$ with $2^a 3^b$:
#+begin_src scheme
  (define (cons a b)
    (* (expt 2 a) (expt 3 b)))

  (define (factor x a)
    (define (iter x n)
      (if (zero? (remainder x a))
          (iter (/ x a) (1+ n))
          n))
    (iter x 0))

  (define (car z) (factor z 2))
  (define (cdr z) (factor z 3))
#+end_src

* Tree structure

#+begin_src scheme
  (define (count-leaves x)
    (cond ((null? x) 0)
          ((not (pair? x)) 1)
          (else (+ (count-leaves (car x))
                   (count-leaves (cdr x))))))

  (define (reverse x)
    (define (iter x res)
      (if (null? x)
          res
          (iter (cdr x) (cons (car x)
                              res))))
    (iter x '()))

  (define (deep-reverse x)
    (define (iter x result)
      (if (null? x)
          result
          (let ((first (car x))
                (rest (cdr x)))
            (iter rest
                  (cons (if (pair? first)
                            (iter first '())
                            first)
                        result)))))
    (iter x '()))

  (define (deep-reverse x)
    (reverse
     (map (lambda (x)
            (if (pair? x)
                (deep-reverse x)
                x))
          x)))

  (define (deep-reverse x)
    (if (pair? x)
        (reverse (map deep-reverse x))
        x))

  (define (fringe x)
    (cond ((null? x) '())
          ((pair? (car x)) (append (fringe (car x))
                                   (fringe (cdr x))))
          (else (cons (car x) (fringe (cdr x))))))


  (define (scale-tree tree factor)
    (cond ((null? tree) '())
          ((not (pair? tree)) (* tree factor))
          (else (cons (scale-tree (car tree) factor)
                      (scale-tree (cdr tree) factor)))))

  (define (scale-tree tree factor)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (scale-tree sub-tree factor))
                 (else (* sub-tree factor))))
         tree))


  (define (square-tree tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (square-tree (car tree))
                              (square-tree (cdr tree))))
          (else (square tree))))

  (define (square-tree tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (square-tree sub-tree))
                 (else (square sub-tree))))
         tree))

  (square-tree '(1 (2 (3 4) 5) (6 7)))

  (define (tree-map fun tree)
    (cond ((null? tree) '())
          ((pair? tree) (cons (tree-map fun (car tree))
                              (tree-map fun (cdr tree))))
          (else (fun tree))))

  (define (tree-map fun tree)
    (map (lambda (sub-tree)
           (cond ((null? sub-tree) '())
                 ((pair? sub-tree) (tree-map fun sub-tree))
                 (else (fun sub-tree))))
         tree))
#+end_src

* Sequences as Conventional Interfaces

#+begin_src scheme
  (define (filter predicate sequence)
    (if (null? sequence)
        '()
        (let ([first (car sequence)]
              [rest  (cdr sequence)])
          (if (predicate first)
              (cons first
                    (filter predicate rest))
              (filter predicate rest)))))

  (filter odd? '(1 2 3 4 5 6))            ; (1 3 5)

  (define (accumulate op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (accumulate op initial (cdr sequence)))))

  (accumulate * 1 '(1 2 3 4 5))           ; 120
  (accumulate cons '() '(1 2 3 4 5))      ; (1 2 3 4 5)

  (define (map f sequence)
    (accumulate (lambda (first rest)
                  (cons (f first)
                        rest))
                '()
                sequence))

  (map 1+ '(1 2 3))                       ; (2 3 4)

  (define (append s1 s2)
    (accumulate cons s2 s1))

  (append '(1 2 3) '(4 5 6))              ; (1 2 3 4 5 6)

  (define (length s)
    (accumulate (lambda (_ c)
                  (1+ c))
                0 s))

  (length '(1 2 3))                       ; 3

  (define (enumerate-interval low high)
    (if (> low high)
        '()
        (cons low
              (enumerate-interval (+ low 1) high))))

  (enumerate-interval 2 7)                ; (2 3 4 5 6 7)

  (define (enumerate-tree tree)
    (cond [(null? tree) '()]
          [(atom? tree) (list tree)]
          [else (append (enumerate-tree (car tree))
                        (enumerate-tree (cdr tree)))]))

  (enumerate-tree '(1 (2 (3 4)) 5))       ; (1 2 3 4 5)


  (define (sum-odd-squares tree)
    (accumulate + 0
                (map square
                     (filter odd?
                             (enumerate-tree tree)))))

  (define (even-fibs n)
    (accumulate cons '()
                (filter even?
                        (map fib
                             (enumerate-interval 0 n)))))

  (define (salary-of-highest-paid-programmer records)
    (accumulate max 0
                (map salary
                     (filter programmer? records))))
#+end_src

* Folding left & right

Both =fold-left= and =fold-right= takes
- =op=: a procedure with two arguments
- =initial=: the initial value
- =sequence=: the sequence to be accumulated/folded.

#+begin_src scheme
  (define (fold-left op initial sequence)
    (define (iter result rest)
      (if (null? rest)
          result
          (iter (op result (car rest))
                (cdr rest))))
    (iter initial sequence))

  (define (fold-right op initial sequence)
    (if (null? sequence)
        initial
        (op (car sequence)
            (fold-right op initial (cdr sequence)))))
#+end_src

But they apply =op= in different directions.
=fold-left= folds from left to right, calls =(op running-sum current-value)=.
=fold-right= folds from right to left, calls =(op current-value running-sum)=.

For operators that satisfy transitivity, the result is the same, but
for others such as division and =cons=, the results are different.
#+begin_src scheme
  (fold-left / 1 '(1 2 3))                ; (((1 / 1) / 2) / 3) -> 1/6
  (fold-right / 1 '(1 2 3))               ; (1 / (2 / (3 / 1))) -> 3/2
#+end_src

You can implement =reverse= using either, but with different =op=:
#+begin_src scheme
  (define (reverse sequence)
    (fold-left (lambda (sum cur)
                 (cons cur sum))
               '()
               sequence))

  (define (reverse sequence)
    (fold-right (lambda (cur sum)
                  (append sum (list cur)))
                '()
                sequence))
#+end_src

* Functional Geometry

See [[https://github.com/thebesttv/functional-geometry][this]] repo.

* Symbolic Differentiation

#+begin_quote
I've chosen my representation to be the same as the representation in my language.
#+end_quote

Note the use of quotes (='=).  We're talking about the symbol =+= and
=*=, instead of the procedures they represent.

#+include: "./ch2/deriv.scm" src scheme

This representation, however, does not allow arbitrary numbers of
terms for =+= and =*=.
#+begin_src scheme
  (deriv '(+ x x x x) 'x)                 ; 2
  (deriv '(* x x x) 'x)                   ; (+ x x)
#+end_src

To incorporate multiple terms while not changing =deriv=, we just need
to change the representation.  =a2= will now check the number of
arguments of the expression.  If only two, then return the second one
as usual.  =a2= will make another sum expression if there're more than
two arguments.  The same is true for =m2=.
#+begin_src scheme
  (define (a2 exp)
    (if (null? (cdddr exp))
        (caddr exp)
        (cons '+ (cddr exp))))

  (define (m2 exp)
    (if (null? (cdddr exp))
        (caddr exp)
        (cons '* (cddr exp))))

  (deriv '(+ x x x x) 'x)                 ; 4
  (deriv '(* x x x) 'x)                   ; (+ (* x (+ x x)) (* x x))
#+end_src

* Flatmap

To produce a list of ordered pairs $(i, j)$ s.t. $1 \le i \le j \le
n$, first we nest two =map=​s:
#+begin_src scheme
  (let ([n 3])
    (map (lambda (i)
           (map (lambda (j) (list i j))
                (enumerate-interval i n)))
         (enumerate-interval 1 n)))
  ;; (((1 1) (1 2) (1 3))
  ;;  ((2 2) (2 3))
  ;;  ((3 3)))
#+end_src

The result is a list of lists.  Use =accumulate= on the outer list to
flatten it:
#+begin_src scheme
  (let ([n 3])
    (accumulate append '()
                (map (lambda (i)
                       (map (lambda (j) (list i j))
                            (enumerate-interval i n)))
                     (enumerate-interval 1 n))))
  ;; ((1 1) (1 2) (1 3) (2 2) (2 3) (3 3))
#+end_src

The combination of mapping and accumulating with append is so common
in this sort of program that we will isolate it as a separate
procedure:
#+begin_src scheme
  (define (flatmap proc seq)
    (accumulate append '()
                (map proc seq)))
#+end_src

Then we can define ordered pairs and even ordered triplets:
#+begin_src scheme
  (define (ordered-pairs n)
    (flatmap (lambda (i)
               (map (lambda (j) (list i j))
                    (enumerate-interval 1 n)))
             (enumerate-interval 1 n)))

  (ordered-pairs 3)
  ;; ((1 1) (1 2) (1 3) (2 1) (2 2) (2 3) (3 1) (3 2) (3 3))

  (define (ordered-triplets n)
    (flatmap (lambda (x)
               (map (lambda (l) (cons x l))
                    (ordered-pairs n)))
             (enumerate-interval 1 n)))

  (ordered-triplets 2)
  ;; ((1 1 1) (1 1 2) (1 2 1) (1 2 2) (2 1 1) (2 1 2) (2 2 1) (2 2 2))
#+end_src

* List as tree as set

Implement an ordered set of numbers using binary search tree.  A tree
is a list of 3 elements---an =entry= in the set, its left branch, and
right branch.
#+begin_src scheme
  (define (entry tree) (car tree))          ; first
  (define (left-branch tree) (cadr tree))   ; second
  (define (right-branch tree) (caddr tree)) ; third
  (define (make-tree entry left right)
    (list entry left right))
#+end_src

Finding an element of a balanced tree takes $O(\log n)$ time.
#+begin_src scheme
  (define (element-of-set? x set)
    (cond [(null? set) #f]
          [(= x (entry set)) #t]
          [(> x (entry set)) (element-of-set? x (left-branch set))]
          [else (element-of-set? x (right-branch set))]))
#+end_src

=adjoin-set= inserts entry =x= to tree =set=:
#+begin_src scheme
  (define (adjoin-set x set)
    (cond [(null? set) (make-tree x '() '())]
          [(= x (entry set)) set]         ; already in the set
          [(> x (entry set))              ; insert to left branch
           (make-tree (entry set)
                      (adjoin-set x (left-branch set))
                      (right-branch set))]
          [else                           ; insert to right branch
           (make-tree (entry set)
                      (left-branch set)
                      (adjoin-set x (right-branch set)))]))
#+end_src

Flattening a tree into list using inorder traversal:
#+begin_src scheme
  ;;; [1] append makes this slower than [2]
  (define (tree->list-1 tree)
    (if (null? tree)
        '()
        (append (tree->list-1 (left-branch tree))
                (cons (entry tree)
                      (tree->list-1 (right-branch tree))))))
  ;;; [2]
  (define (tree->list-2 tree)
    (define (copy-to-list tree result-list)
      (if (null? tree)
          result-list
          (copy-to-list (left-branch tree)
                        (cons (entry tree)
                              (copy-to-list (right-branch tree)
                                            result-list)))))
    (copy-to-list tree '()))

  (define tree (make-tree 7
                          (make-tree 3
                                     (make-tree 1 '() '())
                                     (make-tree 5 '() '()))
                          (make-tree 9
                                     '()
                                     (make-tree 11 '() '()))))

  (tree->list-1 tree)                     ; (1 3 5 7 9 11)
  (tree->list-2 tree)                     ; (1 3 5 7 9 11)
#+end_src

Converting an ordered list to a balanced tree: (Ex 2.64)
#+begin_quote
The following procedure =list->tree= converts an ordered list to a
balanced binary tree.  The helper procedure =partial-tree= takes as
arguments an integer $n$ and list of at least $n$ elements and
constructs a balanced tree containing *the first $n$ elements* of the
list.  The result returned by =partial-tree= is a *pair* (formed with
=cons=) whose =car= is the constructed tree and whose =cdr= is the
list of elements *not included in the tree*.
#+begin_src scheme
  (define (list->tree l)
    (define (partial-tree elts n)
      (if (= n 0)
          (cons '() elts)                 ; an empty tree & (rest of) the list
          (let* ([left-size (quotient (- n 1) 2)]
                 [right-size (- n left-size 1)]
                 [left-result (partial-tree elts left-size)]
                 [left-tree (car left-result)]
                 [non-left-elts (cdr left-result)]
                 [this-entry (car non-left-elts)]
                 [right-elts (cdr non-left-elts)]
                 [right-result (partial-tree right-elts right-size)]
                 [right-tree (car right-result)]
                 [remaining-elts (cdr right-result)])
            (cons (make-tree this-entry
                             left-tree
                             right-tree)
                  remaining-elts))))
    (car (partial-tree l (length l))))

  (tree->list-1 (list->tree '(1 2 3 4)))  ; (1 2 3 4)
#+end_src
#+end_quote

* Huffman encoding tree

In a huffman tree, a /node/ is either a general tree, or a leaf.  In
the following code, =node= refers to either a general tree or a leaf,
=leaf= refers specifically to a leaf, and =tree= a general tree.

A /leaf/ is represented by a list consisting of the symbol =leaf=, the
symbol at the leaf, and its weight.
#+begin_src scheme
  (define (make-leaf symbol weight)
    (list 'leaf symbol weight))
  (define (leaf? node) (eq? (car node) 'leaf))
  (define (symbol-leaf leaf) (cadr leaf))
  (define (weight-leaf leaf) (caddr leaf))
#+end_src

A /general tree/ is a list of a left branch, a right branch, a set of
symbols, and a weight.  The procedures =symbols= and =weight= must do
something slightly different depending on whether they are called with
a leaf or a general tree.
#+begin_src scheme
  (define (make-code-tree left right)
    (list left
          right
          (append (symbols left) (symbols right))
          (+ (weight left) (weight right))))
  (define (left-branch tree) (car tree))
  (define (right-branch tree) (cadr tree))
  (define (symbols node)
    (if (leaf? node)
        (list (symbol-leaf node))
        (caddr node)))
  (define (weight node)
    (if (leaf? node)
        (weight-leaf node)
        (cadddr node)))
#+end_src

The decode process is not hard.  It takes =bits= (a list of 0's and
1's) and the Huffman tree.  At each run, if
1. =node= is a leaf, it means the bit just processed ends a symbol,
   and the remaining =bits= can either be empty [2], or represent yet
   more symbols [3,4].  So we =cons= that symbol to the result, and
   restart at the root of the tree.
2. =node= is not a leaf and =bits= is empty, then the decode process
   ends.
3. the bit is 0, then go to the left branch.
4. the bit is 1, then go to the right branch.
5. the bit is neither 0 or 1, there's a bad bit in =bits=.

#+begin_src scheme
  (define (decode bits tree)
    (define (run bits node)
      (cond [(leaf? node) (cons (symbol-leaf node) (run bits tree))] ; [1]
            [(null? bits) '()]                                       ; [2]
            [(= (car bits) 0) (run (cdr bits) (left-branch node))]   ; [3]
            [(= (car bits) 1) (run (cdr bits) (right-branch node))]  ; [4]
            [else (error "bad bit in DECODE" (car bits))]))          ; [5]
    (run bits tree))
#+end_src

Example of decode:
#+begin_src scheme
  (define sample-tree
    (make-code-tree (make-leaf 'A 4)
                    (make-code-tree (make-leaf 'B 2)
                                    (make-code-tree (make-leaf 'D 1)
                                                    (make-leaf 'C 1)))))

  (define sample-bits '(0 1 1 0 0 1 0 1 0 1 1 1 0))
  (define sample-message '(A D A B B C A))

  (equal? (decode sample-bits sample-tree) sample-message) ; #t
#+end_src

The encode process:
#+begin_src scheme
  (define (encode msg tree)
    (define (encode-symbol symbol node)
      (if (leaf? node)
          '()
          (let ([left (left-branch node)]
                [right (right-branch node)])
            (cond [(memq symbol (symbols left))
                   (cons 0 (encode-symbol symbol left))]
                  [(memq symbol (symbols right))
                   (cons 1 (encode-symbol symbol right))]
                  [else (error "Symbol not in tree:" symbol)]))))
    (if (null? msg)
        '()
        (append (encode-symbol (car msg) tree)
                (encode (cdr msg) tree))))

  (equal? (encode sample-message sample-tree) sample-bits) ; #t
#+end_src

In building the Huffman tree, the symbol-frequency pairs are given
where all the symbols are unique.  The =pairs= are first converted by
=make-leaf-set= to an ordered set (list) of leaves, and then merged to
the final tree (which we'll talk later).  =adjoin-set= adds =node=
(note this is a /node/, not just a /leaf/) to an ordered list =set=.
It assumes =node= is never in =set=.
#+begin_src scheme
  ;;; This is defined later.
  ;; (define (generate-huffman-tree pairs)
  ;;   (successive-merge (make-leaf-set pairs)))

  (define (adjoin-set node set)
    (cond [(null? set) (list node)]
          [(< (weight node) (weight (car set))) (cons node set)]
          [else (cons (car set)
                      (adjoin-set node (cdr set)))]))

  (define (make-leaf-set pairs)
    (if (null? pairs)
        '()
        (let ([pair (car pairs)]
              [rest (cdr pairs)])
          (adjoin-set (make-leaf (car pair) (cadr pair))
                      (make-leaf-set rest)))))

  (define sample-pairs '((A 4) (B 2) (C 1) (D 1)))
  (make-leaf-set sample-pairs)
  ;; ((leaf D 1) (leaf C 1) (leaf B 2) (leaf A 4))
#+end_src

=successive-merge= uses =make-code-tree= to successively merge the
smallest-weight elements of the set until there's only one element
left.  The ordered set originally contains only leaves, but the leaves
are merged to become general tree nodes.
#+begin_src scheme
  (define (generate-huffman-tree pairs)
    (define (successive-merge set)
      (if (null? (cdr set))
          (car set)                 ; only one wlement left, it's the tree
          (let ([first (car set)]
                [second (cadr set)]
                [rest (cddr set)])
            (successive-merge
             (adjoin-set (make-code-tree first second) ; merge first & second
                         rest)))))                     ; and join with rest
    (successive-merge (make-leaf-set pairs)))

  (generate-huffman-tree sample-pairs)
  ;; ((leaf A 4)
  ;;  ((leaf B 2)
  ;;   ((leaf D 1) (leaf C 1) (D C) 2)
  ;;   (B D C)
  ;;   4)
  ;;  (A B D C)
  ;;  8)

  (let ([tree (generate-huffman-tree sample-pairs)])
    (and (equal? (encode sample-message tree) sample-bits)
         (equal? (decode sample-bits tree) sample-message))) ; #t
#+end_src

* Exercises

** Ex 2.6 -- Church numerals
#+begin_quote
In case representing pairs as procedures wasn't mind-boggling enough,
consider that, in a language that can manipulate procedures, we can
get by without numbers (at least insofar as non-negative integers are
concerned) by implementing 0 and the operation of adding 1 as

#+begin_src scheme
  (define zero (lambda (f) (lambda (x) x)))

  (define (add-1 n) (lambda (f) (lambda (x) (f ((n f) x)))))
#+end_src

This representation is known as /Church numerals/, after its inventor,
Alonzo Church, the logician who invented the calculus.

Define =one= and =two= directly (not in terms of =zero= and
=add-1=). (Hint: Use substitution to evaluate =(add-1 zero)=). Give a
direct definition of the addition procedure =+= (not in terms of
repeated application of =add-1=).
#+end_quote

First we have =zero= and =add-1=:
#+begin_src scheme
  (define zero
    (λ (f)
      (λ (x)
        x)))

  (define (add-1 n)
    (λ (f)
      (λ (x)
        (f ((n f) x)))))
#+end_src

Use the substitution model to calculate =one= and =two=, we get:
#+begin_src scheme
  (define one
    (λ (f)
      (λ (x)
        (f x))))

  (define two
    (λ (f)
      (λ (x)
        (f (f x)))))
#+end_src

In order to get 3, we can add =one= and =two=, and obtain as result
something like =(f (f (f x)))=.  =((one f) x)= is =(f x)=, =(two f)=
is =(λ (x) (f (f x)))=.  Make =((one f) x)= the argument of =(two f)=,
we get:
#+begin_src scheme
  ((two f) ((one f) x))                   ; => (f (f (f x)))
#+end_src

So addition is:
#+begin_src scheme
  (define (add a b)
    (λ (f)
      (λ (x)
        ((a f) ((b f) x)))))
#+end_src

One can use these as normal integers:
#+begin_src scheme
  (define (church->int ch)
    ((ch 1+) 0))

  (church->int zero)                      ; 0
  (church->int two)                       ; 2
  (church->int (add one two))             ; 3

  (define three (add one two))
  (church->int (add two three))           ; 5
#+end_src

Here's a more concise implementation of =add= that I don't quite
understand =@_@=
#+begin_src scheme
  (define (add a b)
    ((a add-1) b))
#+end_src

** Ex 2.20 -- dotted-tail notation
#+begin_quote
The procedures =+=, =*=, and =list= take arbitrary numbers of
arguments.  One way to define such procedures is to use define with
/dotted-tail notation/.  In a procedure definition, a parameter list
that has a dot before the last parameter name indicates that, when the
procedure is called, the initial parameters (if any) will have as
values the initial arguments, as usual, but the final parameter's
value will be a /list/ of any remaining arguments.  For instance,
given the definition
#+begin_src scheme
  (define (f x y . z) <body>)
#+end_src
the procedure =f= can be called with two or more arguments.
If we evaluate
#+begin_src scheme
  (f 1 2 3 4 5 6)
#+end_src
then in the body of =f=, =x= will be 1, =y= will be 2, and =z= will be
the list =(3 4 5 6)=.  Given the definition
#+begin_src scheme
  (define (g . w) <body>)
#+end_src
the procedure =g= can be called with zero or more arguments.
If we evaluate
#+begin_src scheme
  (g 1 2 3 4 5 6)
#+end_src
then in the body of =g=, w will be the list =(1 2 3 4 5 6)=.

Use this notation to write a procedure =same-parity= that takes one or
more integers and returns a list of all the arguments that have the
same even-odd parity as the first argument.  For example,
#+begin_src scheme
  (same-parity 1 2 3 4 5 6 7)
  (1 3 5 7)

  (same-parity 2 3 4 5 6 7)
  (2 4 6)
#+end_src
#+end_quote

#+begin_src scheme
  (define (same-parity first . rest)
    (let ([pred (if (odd? first)
                    odd?
                    even?)])
      (define (iter l)
        (if (null? l)
            '()
            (let ([first (car l)]
                  [rest  (cdr l)])
              (if (pred first)
                  (cons first (iter rest))
                  (iter rest)))))
      (cons first
            (iter rest))))

  ;;; old solution
  (define (same-parity first . rest)
    (let ((yes? (if (odd? first)
                    odd?
                    even?)))
      (define (iter l res)
        (cond ((null? l) res)
              ((yes? (car l)) (iter (cdr l) (cons (car l) res)))
              (else (iter (cdr l) res))))
      (cons first
            (reverse (iter rest '())))))
#+end_src

** Ex 2.27 -- deep reverse

#+begin_quote
Modify your =reverse= procedure of Exercise 2.18 to produce a
=deep-reverse= procedure that takes a list as argument and returns as
its value the list with its elements reversed and with all sub-lists
deep-reversed as well.  For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4))) ; ((1 2) (3 4))
  (reverse x)                             ; ((3 4) (1 2))
  (deep-reverse x)                        ; ((4 3) (2 1))
#+end_src
#+end_quote

#+begin_src scheme
  (define (deep-reverse tree)
    (if (atom? tree)
        tree
        (reverse (map deep-reverse tree))))
#+end_src

** Ex 2.28 -- fringe

#+begin_quote
Write a procedure =fringe= that takes as argument a tree (represented as
a list) and returns a list whose elements are all the leaves of the
tree arranged in left-to-right order.  For example,
#+begin_src scheme
  (define x (list (list 1 2) (list 3 4)))
  (fringe x)                              ; (1 2 3 4)
  (fringe (list x x))                     ; (1 2 3 4 1 2 3 4)
#+end_src
#+end_quote

#+begin_src scheme
  (define (fringe tree)
    (cond [(null? tree) '()]
          [(atom? tree) (list tree)]
          [else (append (fringe (car tree))
                        (fringe (cdr tree)))]))

  (define (fringe tree)
    (define (iter tree res)
      (cond [(null? tree) res]
            [(atom? tree) (cons tree res)]
            [else (iter (car tree)
                        (iter (cdr tree) res))]))
    (iter tree '()))
#+end_src

** Ex 2.32 -- subset
#+begin_quote
We can represent a set as a list of distinct elements, and we can
represent the set of all subsets of the set as a list of lists. For
example, if the set is =(1 2 3)=, then the set of all subsets is =(()
(3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))=. Complete the following
definition of a procedure that generates the set of subsets of a set
and give a clear explanation of why it works:

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list nil)
        (let ((rest (subsets (cdr s))))
          (append rest (map <??> rest)))))
#+end_src
#+end_quote

#+begin_src scheme
  (define (subsets s)
    (if (null? s)
        (list '())
        (let ([rest (subsets (cdr s))])
          (append rest
                  (map (lambda (x)
                         (cons (car s) x))
                       rest)))))
#+end_src

** Ex 2.35 -- counting leaves

#+begin_quote
Redefine count-leaves from Section 2.2.2 as an accumulation.
#+end_quote

#+begin_src scheme
  (define (count-leaves tree)
    (accumulate + 0
                (map (lambda (tree)
                       (if (atom? tree)
                           1
                           (count-leaves tree)))
                     tree)))
#+end_src
This seems fine, but it will count the empty list as a leaf:
#+begin_src scheme
  (count-leaves '(1 2 (3 (4 5) 6) 7))     ; 7
  (count-leaves '(1 2 (3 (4 5) 6) 7 ()))  ; 8
#+end_src

Take into consideration the empty list ='()=:
#+begin_src scheme
  (define (count-leaves tree)
    (accumulate + 0
                (map (lambda (tree)
                       (cond [(null? tree) 0]
                             [(atom? tree) 1]
                             [else (count-leaves tree)]))
                     tree)))

  (count-leaves '(1 2 (3 (4 5) 6) 7))     ; 7
  (count-leaves '(1 2 (3 (4 5) 6) 7 ()))  ; 7
#+end_src
