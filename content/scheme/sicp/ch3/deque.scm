(define (make-node v front rear)
  (cons v (cons front rear)))
(define (node-value node) (car  node))
(define (node-front node) (cadr node))
(define (node-rear  node) (cddr node))
(define (set-node-front! node value)
  (set-car! (cdr node) value))
(define (set-node-rear!  node value)
  (set-cdr! (cdr node) value))

(define (make-deque) (cons '() '()))
(define (front-ptr queue) (car queue))
(define (rear-ptr  queue) (cdr queue))
(define (set-front-ptr! queue value)
  (set-car! queue value))
(define (set-rear-ptr!  queue value)
  (set-cdr! queue value))

(define (empty-deque? queue)
  (null? (front-ptr queue)))

(define (front-deque queue)
  (if (empty-deque? queue)
      (error "FRONT called with an empty deque" queue)
      (node-value (front-ptr queue))))

(define (rear-deque queue)
  (if (empty-deque? queue)
      (error "REAR called with an empty deque" queue)
      (node-value (rear-ptr queue))))

(define (front-insert-deque! queue item)
  (if (empty-deque? queue)
      (let ([node (make-node item '() '())])
        (set-front-ptr! queue node)
        (set-rear-ptr!  queue node))
      (let* ([front (front-ptr queue)]
             [node (make-node item '() front)])
        (set-node-front! front node)
        (set-front-ptr! queue node)))
  queue)

(define (rear-insert-deque! queue item)
  (if (empty-deque? queue)
      (let ([node (make-node item '() '())])
        (set-front-ptr! queue node)
        (set-rear-ptr!  queue node))
      (let* ([rear (rear-ptr queue)]
             [node (make-node item rear '())])
        (set-node-rear! rear node)
        (set-rear-ptr! queue node)))
  queue)

(define (front-delete-deque! queue)
  (when (empty-deque? queue)
    (error "FRONT-DELETE! called with an empty deque" queue))
  (let ([next (node-rear (front-ptr queue))])
    (set-front-ptr! queue next)
    (unless (null? next)
      (set-node-front! next '())))
  queue)

(define (rear-delete-deque! queue)
  (when (empty-deque? queue)
    (error "REAR-DELETE! called with an empty deque" queue))
  (let ([prev (node-front (rear-ptr queue))])
    (if (null? prev)
        (set-front-ptr! queue '())
        (begin (set-rear-ptr! queue prev)
               (set-node-rear! prev '()))))
  queue)

(define (deque->list queue)
  (if (empty-deque? queue)
      '()
      (let iter ([node (front-ptr queue)])
        (if (null? node) '()
            (cons (node-value node)
                  (iter (node-rear node)))))))

(define q (make-deque))
(deque->list q)                         ; ()
(deque->list (front-insert-deque! q 1)) ; (1)
(deque->list (front-insert-deque! q 0)) ; (0 1)
(deque->list (rear-insert-deque! q 2))  ; (0 1 2)
(deque->list (rear-insert-deque! q 3))  ; (0 1 2 3)
(deque->list (front-delete-deque! q))   ; (1 2 3)
(deque->list (front-delete-deque! q))   ; (2 3)
(deque->list (rear-delete-deque! q))    ; (2)
(deque->list (rear-delete-deque! q))    ; ()
